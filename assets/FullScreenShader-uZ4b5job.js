import{_ as D,r as b,c as N,k as C,l as j,w as H,i as x,d as w,f as Y,j as E,t as F,F as X,m as Z,p as K,o as J,a as T,q as Q}from"./index-frrM4VUH.js";class P{constructor(e,t={}){if(new.target===P)throw new Error("BaseRenderer est une classe abstraite");this.canvas=e,this.options=t}async initialize(e){throw new Error("initialize() doit √™tre impl√©ment√©e")}setUniforms(e){throw new Error("setUniforms() doit √™tre impl√©ment√©e")}render(){throw new Error("render() doit √™tre impl√©ment√©e")}dispose(){throw new Error("dispose() doit √™tre impl√©ment√©e")}getType(){throw new Error("getType() doit √™tre impl√©ment√©e")}}class W extends P{constructor(e,t={}){super(e,t),this.gl=null,this.program=null,this.uniformLocations={}}async initialize(e){try{if(this.gl=this.canvas.getContext("webgl")||this.canvas.getContext("experimental-webgl"),!this.gl)throw new Error("WebGL non support√©");const t=this._createShader(this.gl.VERTEX_SHADER,e.vertex),r=this._createShader(this.gl.FRAGMENT_SHADER,e.fragment);this.program=this._createProgram(t,r),this.gl.deleteShader(t),this.gl.deleteShader(r);const s=new Float32Array([-1,-1,1,-1,-1,1,1,1]),o=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,o),this.gl.bufferData(this.gl.ARRAY_BUFFER,s,this.gl.STATIC_DRAW);const a=this.gl.getAttribLocation(this.program,"a_position");this.gl.enableVertexAttribArray(a),this.gl.vertexAttribPointer(a,2,this.gl.FLOAT,!1,0,0),this.gl.useProgram(this.program),this._cacheUniformLocations(["u_resolution","u_time","u_offset","u_zoom"])}catch(t){throw new Error(`WebGL initialization failed: ${t.message}`)}}_createShader(e,t){const r=this.gl.createShader(e);if(this.gl.shaderSource(r,t),this.gl.compileShader(r),!this.gl.getShaderParameter(r,this.gl.COMPILE_STATUS)){const s=this.gl.getShaderInfoLog(r);throw this.gl.deleteShader(r),new Error(`Shader compilation error: ${s}`)}return r}_createProgram(e,t){const r=this.gl.createProgram();if(this.gl.attachShader(r,e),this.gl.attachShader(r,t),this.gl.linkProgram(r),!this.gl.getProgramParameter(r,this.gl.LINK_STATUS)){const s=this.gl.getProgramInfoLog(r);throw this.gl.deleteProgram(r),new Error(`Program link error: ${s}`)}return r}_cacheUniformLocations(e){e.forEach(t=>{this.uniformLocations[t]=this.gl.getUniformLocation(this.program,t)})}setUniforms(e){if(!(!this.gl||!this.program)){e.resolution&&this.uniformLocations.u_resolution&&this.gl.uniform2f(this.uniformLocations.u_resolution,e.resolution.x,e.resolution.y),e.time!==void 0&&this.uniformLocations.u_time&&this.gl.uniform1f(this.uniformLocations.u_time,e.time),e.offset&&this.uniformLocations.u_offset&&this.gl.uniform2f(this.uniformLocations.u_offset,e.offset.x,e.offset.y),e.zoom!==void 0&&this.uniformLocations.u_zoom&&this.gl.uniform1f(this.uniformLocations.u_zoom,e.zoom);for(const[t,r]of Object.entries(e)){if(["resolution","time","offset","zoom"].includes(t))continue;const s=`u_${t}`,o=this.gl.getUniformLocation(this.program,s);o!==null&&(typeof r=="number"?this.gl.uniform1f(o,r):r&&typeof r=="object"&&(r.x!==void 0&&r.y!==void 0&&r.z!==void 0?this.gl.uniform3f(o,r.x,r.y,r.z):r.x!==void 0&&r.y!==void 0&&this.gl.uniform2f(o,r.x,r.y)))}}}render(){!this.gl||!this.program||(this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4))}dispose(){this.gl&&this.program&&(this.gl.deleteProgram(this.program),this.program=null),this.gl=null,this.uniformLocations={}}getType(){return"webgl"}}const ee=Object.freeze(Object.defineProperty({__proto__:null,WebGLRenderer:W},Symbol.toStringTag,{value:"Module"}));class te extends P{constructor(e,t={}){super(e,t),this.device=null,this.context=null,this.pipeline=null,this.uniformBuffer=null,this.bindGroup=null}async initialize(e){try{if(!navigator.gpu)throw new Error("WebGPU non support√© par ce navigateur");const t=await navigator.gpu.requestAdapter();if(!t)throw new Error("Aucun adaptateur WebGPU trouv√©");this.device=await t.requestDevice(),this.context=this.canvas.getContext("webgpu");const r=navigator.gpu.getPreferredCanvasFormat();this.context.configure({device:this.device,format:r,alphaMode:"opaque"}),this.uniformBuffer=this.device.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const s=this.device.createShaderModule({code:this._buildFullShader(e.vertex,e.fragment)}),o=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),a=this.device.createPipelineLayout({bindGroupLayouts:[o]});this.pipeline=this.device.createRenderPipeline({layout:a,vertex:{module:s,entryPoint:"vs_main"},fragment:{module:s,entryPoint:"fs_main",targets:[{format:r}]},primitive:{topology:"triangle-strip"}}),this.bindGroup=this.device.createBindGroup({layout:o,entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]})}catch(t){throw new Error(`WebGPU initialization failed: ${t.message}`)}}_buildFullShader(e,t){return`
      struct Uniforms {
        resolution: vec2<f32>,
        time: f32,
        _padding1: f32,
        offset: vec2<f32>,
        zoom: f32,
        _padding2: f32,
      }

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;

      ${e||`
      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
        // Rectangle plein √©cran (triangle strip)
        var pos = array<vec2<f32>, 4>(
          vec2<f32>(-1.0, -1.0),
          vec2<f32>( 1.0, -1.0),
          vec2<f32>(-1.0,  1.0),
          vec2<f32>( 1.0,  1.0)
        );
        return vec4<f32>(pos[vertexIndex], 0.0, 1.0);
      }
    `}

      ${t}
    `}setUniforms(e){if(!this.device||!this.uniformBuffer)return;const t=new Float32Array(8);e.resolution&&(t[0]=e.resolution.x,t[1]=e.resolution.y),e.time!==void 0&&(t[2]=e.time),t[3]=0,e.offset&&(t[4]=e.offset.x,t[5]=-e.offset.y),e.zoom!==void 0&&(t[6]=e.zoom),t[7]=0,this.device.queue.writeBuffer(this.uniformBuffer,0,t)}render(){if(!this.device||!this.pipeline||!this.context)return;const e=this.device.createCommandEncoder(),t=this.context.getCurrentTexture().createView(),r=e.beginRenderPass({colorAttachments:[{view:t,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});r.setPipeline(this.pipeline),r.setBindGroup(0,this.bindGroup),r.draw(4),r.end(),this.device.queue.submit([e.finish()])}dispose(){this.uniformBuffer&&(this.uniformBuffer.destroy(),this.uniformBuffer=null),this.pipeline=null,this.bindGroup=null,this.context=null,this.device=null}getType(){return"webgpu"}}class re{static async create(e,t={}){const{preferredRenderer:r="auto",hasWGSL:s=!1}=t,o=[];let a=null;r==="webgl"?a="webgl":r==="webgpu"?s?this.isWebGPUAvailable()?a="webgpu":(o.push("WebGPU demand√© mais non disponible sur ce navigateur. Fallback vers WebGL."),a="webgl"):(o.push("WebGPU demand√© mais pas de shaders WGSL fournis. Fallback vers WebGL."),a="webgl"):this.isWebGPUAvailable()&&s?a="webgpu":(a="webgl",!s&&this.isWebGPUAvailable()&&o.push("WebGPU disponible mais pas de shaders WGSL fournis. Utilisation de WebGL."));let f;if(a==="webgpu")try{f=new te(e,t),await f.initialize({vertex:t.wgslVertex,fragment:t.wgslFragment})}catch(L){o.push(`WebGPU initialization failed: ${L.message}. Fallback vers WebGL.`),a="webgl",f=new W(e,t)}else f=new W(e,t);return{renderer:f,warnings:o,selectedType:a}}static async isWebGPUAvailable(){if(!("gpu"in navigator))return!1;try{return await navigator.gpu.requestAdapter()!==null}catch{return!1}}static getCapabilities(){return{webgl:this.isWebGLAvailable(),webgpu:this.isWebGPUAvailable()}}static isWebGLAvailable(){try{const e=document.createElement("canvas");return!!(e.getContext("webgl")||e.getContext("experimental-webgl"))}catch{return!1}}}const ie={class:"shader-container"},ne=["width","height"],ae={key:0,class:"error"},oe={key:1,class:"warnings"},se={key:2,class:"renderer-info"},le={__name:"WebGLShader",props:{vertexShader:{type:String,default:`
      attribute vec4 a_position;
      void main() {
        gl_Position = a_position;
      }
    `},fragmentShader:{type:String,default:`
      precision mediump float;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec2 u_offset;
      uniform float u_zoom;

      void main() {
        float aspect = u_resolution.x / u_resolution.y;
        vec2 uv = (gl_FragCoord.xy / u_resolution) / u_zoom + u_offset;
        uv = uv * vec2(aspect, 1.0);

        vec2 grid = fract(uv * 10.0);
        float line = step(0.95, grid.x) + step(0.95, grid.y);

        vec2 center = floor(uv * 10.0) + 0.5;
        center = center / 10.0;
        float dist = length(uv - center);
        float circle = smoothstep(0.05, 0.04, dist);

        vec3 color = vec3(fract(center.x), fract(center.y), sin(u_time + center.x + center.y) * 0.5 + 0.5);
        color = mix(vec3(0.1), color, circle);
        color = mix(color, vec3(1.0), line * 0.5);

        gl_FragColor = vec4(color, 1.0);
      }
    `},showWarning:{type:Boolean,default:!1},wgslVertexShader:{type:String,default:null},wgslFragmentShader:{type:String,default:null},width:{type:Number,default:800},height:{type:Number,default:600},renderer:{type:String,default:"auto",validator:l=>["auto","webgl","webgpu"].includes(l)},showRendererInfo:{type:Boolean,default:!1},customUniforms:{type:Object,default:()=>({})},zoomImpactOnOffset:{type:Boolean,default:!0}},setup(l){const e=l,t=b(null),r=b(""),s=b([]),o=b(null);let a=null,f=null,L=Date.now();const c=b({x:0,y:0}),h=b(1);let g=!1,v={x:0,y:0},U=0,S={x:0,y:0};const k=N(()=>!!(e.wgslFragmentShader||e.wgslVertexShader));async function A(){r.value="",s.value=[];try{const n=await re.create(t.value,{preferredRenderer:e.renderer,hasWGSL:k.value,wgslVertex:e.wgslVertexShader,wgslFragment:e.wgslFragmentShader});a=n.renderer,s.value=n.warnings,o.value=n.selectedType;const i=o.value==="webgpu"?{vertex:e.wgslVertexShader,fragment:e.wgslFragmentShader}:{vertex:e.vertexShader,fragment:e.fragmentShader};o.value==="webgl"&&await a.initialize(i),z()}catch(n){if(r.value=`Erreur d'initialisation: ${n.message}`,console.error("Renderer initialization failed:",n),o.value!=="webgl"&&!a)try{console.warn("Tentative de fallback WebGL de secours..."),a=new(await K(async()=>{const{WebGLRenderer:i}=await Promise.resolve().then(()=>ee);return{WebGLRenderer:i}},void 0)).WebGLRenderer(t.value),await a.initialize({vertex:e.vertexShader,fragment:e.fragmentShader}),o.value="webgl",s.value.push("Fallback vers WebGL de secours"),r.value="",z()}catch(i){r.value=`Impossible d'initialiser un renderer: ${i.message}`}}}function z(){if(!a)return;const n=(Date.now()-L)/1e3;a.setUniforms({resolution:{x:e.width,y:e.height},time:n,offset:c.value,zoom:h.value,...e.customUniforms}),a.render(),console.log(e.zoomImpactOnOffset),f=requestAnimationFrame(z)}function R(n){const i=n[0].clientX-n[1].clientX,u=n[0].clientY-n[1].clientY;return Math.sqrt(i*i+u*u)}function O(n){return{x:(n[0].clientX+n[1].clientX)/2,y:(n[0].clientY+n[1].clientY)/2}}function B(){return e.zoomImpactOnOffset?h.value:1}return C(async()=>{await A();const n=t.value;n.addEventListener("mousedown",i=>{g=!0,v={x:i.clientX,y:i.clientY},n.style.cursor="grabbing"}),n.addEventListener("mousemove",i=>{if(!g)return;const u=(i.clientX-v.x)/e.width,d=(i.clientY-v.y)/e.height,p=B();c.value.x-=u/p,c.value.y+=d/p,v={x:i.clientX,y:i.clientY}}),n.addEventListener("mouseup",()=>{g=!1,n.style.cursor="grab"}),n.addEventListener("mouseleave",()=>{g=!1,n.style.cursor="grab"}),n.addEventListener("wheel",i=>{i.preventDefault();const u=n.getBoundingClientRect(),d=(i.clientX-u.left)/e.width,p=1-(i.clientY-u.top)/e.height,m=i.deltaY>0?.9:1.1,y=h.value*m;if(e.zoomImpactOnOffset){const _=d/h.value+c.value.x,G=p/h.value+c.value.y;c.value.x=_-d/y,c.value.y=G-p/y}h.value=y}),n.addEventListener("touchstart",i=>{i.preventDefault(),i.touches.length===1?(g=!0,v={x:i.touches[0].clientX,y:i.touches[0].clientY}):i.touches.length===2&&(g=!1,U=R(i.touches),S=O(i.touches))},{passive:!1}),n.addEventListener("touchmove",i=>{if(i.preventDefault(),i.touches.length===1&&g){const u=i.touches[0],d=(u.clientX-v.x)/e.width,p=(u.clientY-v.y)/e.height,m=B();c.value.x-=d/m,c.value.y+=p/m,v={x:u.clientX,y:u.clientY}}else if(i.touches.length===2){const u=R(i.touches),d=O(i.touches),p=u/U,m=h.value*p;if(e.zoomImpactOnOffset){const y=n.getBoundingClientRect(),_=(d.x-y.left)/e.width,G=1-(d.y-y.top)/e.height,V=_/h.value+c.value.x,$=G/h.value+c.value.y;c.value.x=V-_/m,c.value.y=$-G/m;const q=(d.x-S.x)/e.width,M=(d.y-S.y)/e.height;c.value.x-=q/m,c.value.y+=M/m}else{const y=(d.x-S.x)/e.width,_=(d.y-S.y)/e.height;c.value.x-=y,c.value.y+=_}h.value=m,U=u,S=d}},{passive:!1}),n.addEventListener("touchend",i=>{i.preventDefault(),i.touches.length===0?g=!1:i.touches.length===1&&(g=!0,v={x:i.touches[0].clientX,y:i.touches[0].clientY})},{passive:!1}),n.addEventListener("touchcancel",i=>{i.preventDefault(),g=!1},{passive:!1}),n.style.cursor="grab",n.style.touchAction="none"}),j(()=>{f&&cancelAnimationFrame(f),a&&(a.dispose(),a=null)}),H(()=>[e.vertexShader,e.fragmentShader,e.wgslVertexShader,e.wgslFragmentShader,e.renderer],async()=>{f&&cancelAnimationFrame(f),a&&(a.dispose(),a=null),L=Date.now(),await A()}),(n,i)=>(w(),x("div",ie,[Y("canvas",{ref_key:"canvas",ref:t,width:l.width,height:l.height},null,8,ne),r.value?(w(),x("div",ae,F(r.value),1)):E("",!0),s.value.length&&l.showWarning>0?(w(),x("div",oe,[(w(!0),x(X,null,Z(s.value,(u,d)=>(w(),x("div",{key:d},"‚ö†Ô∏è "+F(u),1))),128))])):E("",!0),l.showRendererInfo&&o.value?(w(),x("div",se," üé® "+F(o.value.toUpperCase()),1)):E("",!0)]))}},I=D(le,[["__scopeId","data-v-f42cdb5c"]]),ce={class:"layout-container"},ue={__name:"FullScreenShader",props:{fragmentShader:{type:String,required:!1,default:`
    precision highp float;
    uniform vec2 u_resolution;
    void main(){
      vec2 uv = gl_FragCoord.xy / u_resolution;
      gl_FragColor = vec4(uv, 0.5 + 0.5 * sin(uv.x * 10.0), 1.0);
    }
    `},fragmentShaderWGSL:{type:String,required:!1,default:null},customUniforms:{type:Object,default:()=>({})},zoomImpactOnOffset:{type:Boolean,default:!0}},setup(l){const e=b(window.innerWidth),t=b(window.innerHeight);function r(){e.value=window.innerWidth,t.value=window.innerHeight}return C(()=>{window.addEventListener("resize",r)}),J(()=>{window.removeEventListener("resize",r)}),(s,o)=>(w(),x(X,null,[l.fragmentShaderWGSL!=null?(w(),T(I,{key:0,class:"fullscreen-shader",width:e.value,height:t.value,fragmentShader:l.fragmentShader,wgslFragmentShader:l.fragmentShaderWGSL,customUniforms:l.customUniforms,zoomImpactOnOffset:l.zoomImpactOnOffset},null,8,["width","height","fragmentShader","wgslFragmentShader","customUniforms","zoomImpactOnOffset"])):(w(),T(I,{key:1,class:"fullscreen-shader",width:e.value,height:t.value,fragmentShader:l.fragmentShader,"custom-uniforms":l.customUniforms,"zoom-impact-on-offset":l.zoomImpactOnOffset},null,8,["width","height","fragmentShader","custom-uniforms","zoom-impact-on-offset"])),Y("div",ce,[Q(s.$slots,"default",{},void 0)])],64))}},fe=D(ue,[["__scopeId","data-v-19a74c44"]]);export{fe as F};
